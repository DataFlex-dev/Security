// For these classes we accept a lower level of security concerning the secrets in memory. Since
// the secret should be different for each user it makes no sense to initialize a hash object and
// reuse it. Nonetheless the IsValid method zeroes out the ucaSecret parameter before returning,
// which is good enough.
//
// Example:
//
//    Object oOneTimePassword is a cTimeBasedOneTimePassword
//        Set piDigitCount to 6
//    End_Object
//
//    Function GetTOTP Returns String
//        Integer iOtp
//        Get TOTP of oOneTimePassword "12345678901234567890" to iOtp
//    End_Function
//
//    Function RandomBase32Secret Returns String
//        Integer iHashImpl
//        Integer iLen
//        String  sSecret
//        UChar[] ucaSecret
//
//        Get piHashImplementation of oOneTimePassword to iHashImpl
//        Get MinimumKeyBytes of ghoSecurity iHashImpl to iLen
//        Get RandomData of ghoSecurity iLen to ucaSecret
//        Move (Bin2Base32(ghoSecurity, ucaSecret)) to sSecret
//
//        Function_Return sSecret
//    End_Function
Use include\UnixTime.pkg

Use DFSecurity.pkg

Define C_SEC_OTPTYPE_HASH for 'hotp'
Define C_SEC_OTPTYPE_TIME for 'totp'

#IFNDEF Get_UrlEncode
Register_Function UrlEncode String sValue Boolean bSegment Returns String
#ENDIF

#IFNDEF Get_UrlDecode
Register_Function UrlDecode String sValue Returns String
#ENDIF

#IF (!@ < 200)
    Define WString for String
    Define UrlEscapeW for UrlEscape
#ENDIF

{ ClassType=Abstract }
Class cSecureOneTimePassword_Impl_Base is a cSecurityObject

    Procedure Construct_Object
        Forward Send Construct_Object

        Property Integer piDigitCount 6
        Property Integer piHashImplementation
        Property String  psAccountName
        Property String  psIssuer
        Property UChar[] pucaSecret
    End_Procedure

    // @returns the secret, encoded base32. If there is no secret yet, a new one will be gerenated.
    //          The length of the new secret depends on the currently selected hash implementation.
    Function SecretAsBase32 Returns String
        Handle  hoOTP
        Integer iHashImpl
        Integer iLen
        UChar[] ucaSecret

        Get pucaSecret to ucaSecret
        If (SizeOfArray(ucaSecret) = 0) Begin
            Get piHashImplementation to iHashImpl
            Get MinimumKeyBytes of ghoSecurity iHashImpl to iLen
            Get RandomData of ghoSecurity iLen to ucaSecret
            Set pucaSecret to ucaSecret
        End

        Function_Return (Bin2Base32(ghoSecurity, ucaSecret))
    End_Function

    { Visibility=Private }
    Function OneTimePassword UBigInt iCounter Returns String
        Handle  hoKeyedHash
        Integer iCount
        Integer iDigitCount
        Integer iOffset
        Integer iOTP
        String  sOTP
        UChar[] ucaCounter
        UChar[] ucaHMAC
        UChar[] ucaSecret

        Get pucaSecret to ucaSecret

        // format the counter for hashing
        Move (SizeOfType(UBigInt)-1) to iCount
        While (iCount >= 0)
            Move (iCounter iand 255) to ucaCounter[iCount]
            Move (iCounter/256) to iCounter
            Decrement iCount
        Loop

        // generate the hash
        Get CreateNamed (RefClass(cSecureHash)) "cSecureHash_OTP" to hoKeyedHash
        Set piHashImplementation of hoKeyedHash to (piHashImplementation(Self))
        Send Initialize of hoKeyedHash ucaSecret
        Send Update of hoKeyedHash ucaCounter
        Get Finalize of hoKeyedHash to ucaHMAC
        Send Destroy of hoKeyedHash

        // extract the OTP value
        Move (ucaHMAC[SizeOfArray(ucaHMAC)-1] iand $0F) to iOffset
        Move (ucaHMAC[iOffset] iand $7F) to iOTP
        Move (iOTP * 256) to iOTP
        Add (ucaHMAC[iOffset+1] iand $FF) to iOTP
        Move (iOTP * 256) to iOTP
        Add (ucaHMAC[iOffset+2] iand $FF) to iOTP
        Move (iOTP * 256) to iOTP
        Add (ucaHMAC[iOffset+3] iand $FF) to iOTP

        // format the OTP string
        Get piDigitCount to iDigitCount
        Move (Right("0000000" + String(iOTP), iDigitCount)) to sOTP

        Function_Return sOTP
    End_Function

    { Visibility=Private }
    Function QrCodeUriParameters String sBase32Secret Returns String[][]
        Integer iHashImpl
        Integer iParam
        String  sHashAlg
        String  sIssuer
        String[][] asParams

        // ToDo: refactor this - hardcoding classes is not optimal...
        Get piHashImplementation to iHashImpl
        Case Begin
#IFDEF C_SEC_HASH_CNG_HMAC_SHA1
            Case (iHashImpl = C_SEC_HASH_CNG_HMAC_SHA1)
                Move "SHA1" to sHashAlg
                Case Break
#ENDIF
#IFDEF C_SEC_HASH_CNG_HMAC_SHA256
            Case (iHashImpl = C_SEC_HASH_CNG_HMAC_SHA256)
#ENDIF
#IFDEF C_SEC_HASH_LIBSODIUM_HMAC_SHA256
            Case (iHashImpl = C_SEC_HASH_LIBSODIUM_HMAC_SHA256)
#ENDIF
                Move "SHA256" to sHashAlg
                Case Break
#IFDEF C_SEC_HASH_CNG_HMAC_SHA512
            Case (iHashImpl = C_SEC_HASH_CNG_HMAC_SHA512)
#ENDIF
#IFDEF C_SEC_HASH_LIBSODIUM_HMAC_SHA512
            Case (iHashImpl = C_SEC_HASH_LIBSODIUM_HMAC_SHA512)
#ENDIF
                Move "SHA512" to sHashAlg
                Case Break
            Case Else
                Error DFERR_PROGRAM "Unknown hash algorithm!"
                Procedure_Return
        Case End

        Move "secret" to asParams[iParam][0]
        Move (UrlEncode(sBase32Secret, True)) to asParams[iParam][1]
        Increment iParam

        Get psIssuer to sIssuer
        Move (UrlEncode(sIssuer, False)) to sIssuer
        Move "issuer" to asParams[iParam][0]
        Move sIssuer to asParams[iParam][1]
        Increment iParam

        Move "algorithm" to asParams[iParam][0]
        Move sHashAlg to asParams[iParam][1]
        Increment iParam

        Move "digits" to asParams[iParam][0]
        Get piDigitCount to asParams[iParam][1]
        Increment iParam

        Function_Return asParams
    End_Function

    // see: https://github.com/google/google-authenticator/wiki/Key-Uri-Format
    Function PackForStorage Returns String
        Integer iParam
        String  sBase32Secret
        String  sType sIssuer sAccountName sLabel sParams
        String  sValue
        String[][] asParams

        // build "label" part of URI
        Get psIssuer to sIssuer
        Get psAccountName to sAccountName
        If (sIssuer contains ':' or sAccountName contains ':') Begin
            Error DFERR_PROGRAM "Issuer and account name MUST NOT contain a colon"
            Function_Return sValue
        End
        Move (UrlEncode(sIssuer, False)) to sIssuer
        Move (UrlEncode(sAccountName, False)) to sAccountName
        Move (If(sIssuer <> '', sIssuer+':', '') + sAccountName) to sLabel

        Get QrCodeUriType to sType

        Get SecretAsBase32 to sBase32Secret

        // squash params
        Get QrCodeUriParameters sBase32Secret to asParams
        For iParam from 0 to (SizeOfArray(asParams)-1)
            If (iParam > 0) Add '&' to sParams
            Add (SFormat("%1=%2", asParams[iParam][0], asParams[iParam][1])) to sParams
        Loop

        // format URI
        Move (SFormat("otpauth://%1/%2?%3", sType, sLabel, sParams)) to sValue

        Function_Return sValue
    End_Function

    Procedure UnpackFromStorage String sInput
        Integer  iParam iLastParam
        Integer  iPos
        String   sParams
        String[] asParams

        Move (Pos('?', sInput)) to iPos
        If (iPos = 0) Begin
            Error DFERR_PROGRAM "Invalid OTP storage string"
            Procedure_Return
        End
        Increment iPos

        // extract parameters
        Move (Mid(sInput, Length(sInput)-iPos+1, iPos)) to sParams
        Move (StrSplitToArray(sParams, '&')) to asParams
        Move (SizeOfArray(asParams)-1) to iLastParam
        For iParam from 0 to iLastParam
            Send UnpackParameterFromStorage asParams[iParam]
        Loop
    End_Procedure

    // ignores unknown parameters
    Procedure UnpackParameterFromStorage String sParam
        Integer iPos
        String  sKey
        String  sValue

        Move (Pos('=', sParam)) to iPos
        If (iPos = 0) Begin
            Error DFERR_PROGRAM "Invalid OTP storage string"
            Procedure_Return
        End

        Move (Mid(sParam, iPos-1, 1)) to sKey
        Move (Mid(sParam, Length(sParam)-iPos, iPos+1)) to sValue

        Case Begin
            Case (sKey = 'secret')
                Get UrlDecode sValue to sValue
                Set pucaSecret to (Base322Bin(ghoSecurity, sValue))
                Case Break
            Case (sKey = 'issuer')
                Set psIssuer to (UrlDecode(sValue))
                Case Break
            Case (sKey = 'algorithm')
//                Set psIssuer to (UrlDecode(parent(Self), sValue))
                Case Break
            Case (sKey = 'digits')
                Set piDigitCount to sValue
                Case Break
        Case End
    End_Procedure

End_Class

{ OverrideProperty=piHashImplementation EnumList="C_SEC_HASH_CNG_HMAC_SHA1" }
Class cSecureHmacBasedOneTimePassword_Impl is a cSecureOneTimePassword_Impl_Base

    Procedure Construct_Object
        Forward Send Construct_Object

        // The current counter value, used for input, and possibly output for resynchronization.
        Property UBigInt piCounter 0

        // HOTP values are counter-based. To prevent a brute force attack using the same OTP code
        // over and over again until it succeeds, it is recommended to ask for 3 consecutive OTP
        // codes. This also allows for resynchronization after failed login attempts.
        Property Integer piHotpQuantity 3

        // The number of additional piCounter values to try, in case the counter is out of sync.
        // Security is lower when this value is higher!
        Property Integer piGraceCount 10
    End_Procedure

    // ignores unknown parameters
    Procedure UnpackParameterFromStorage String sParam
        Integer iPos
        String  sKey
        String  sValue

        Move (Pos('=', sParam)) to iPos
        If (iPos = 0) Begin
            Error DFERR_PROGRAM "Invalid OTP storage string"
            Procedure_Return
        End

        Move (Mid(sParam, iPos-1, 1)) to sKey
        Move (Mid(sParam, Length(sParam)-iPos, iPos+1)) to sValue

        Case Begin
            Case (sKey = 'counter')
                Set piCounter to sValue
                Case Break
            Case Else
                Forward Send UnpackParameterFromStorage sParam
        Case End
    End_Procedure

    // @returns the number of authentication codes required: 1 for TOTP or 3 for HOTP.
    Function RequiredNumberOfCodes Returns Integer
        Integer iQty
        Get piHotpQuantity to iQty
        Function_Return iQty
    End_Function

    { Visibility=Private }
    Function QrCodeUriType Returns String
        Function_Return "hotp"
    End_Function

    { Visibility=Private }
    Function QrCodeUriParameters String sBase32Secret Returns String[][]
        Integer iParam
        String[][] asParams

        Forward Get QrCodeUriParameters sBase32Secret to asParams
        Move (SizeOfArray(asParams)) to iParam

        Move "counter" to asParams[iParam][0]
        Get piCounter to asParams[iParam][1]
        Increment iParam

        Function_Return asParams
    End_Function

    Function Should_Save Returns Boolean
        Function_Return True
    End_Function

    { Visibility=Private }
    Function IsValidCode String sEnteredOtp Boolean bFirst Returns Boolean
        Boolean bIsValid
        Integer iCount
        String  sOtp
        UBigInt iCounter

        Get piCounter to iCounter

        // try expected counter first
        Get OneTimePassword iCounter to sOtp
        If (sOtp = sEnteredOtp) Begin
            Move True to bIsValid
            Set piCounter to (iCounter+1)
        End

        If bFirst Begin
            // if not valid, try next few (piGraceCount) counters
            // this takes care of (re)syncing the counter
            Move 0 to iCount
            While (not(bIsValid) and iCount < piGraceCount(Self))
                Increment iCount

                Get OneTimePassword (iCounter + iCount) to sOtp
                If (sOtp = sEnteredOtp) Begin
                    Move True to bIsValid
                    Set piCounter to (iCounter + iCount)
                End
            Loop
        End

        Function_Return bIsValid
    End_Function

    // @param asEnteredOtps The OTP codes provided by the user, which are to be validated. For HOTP
    //                    this contains multiple codes.
    Function IsValid String[] asEnteredOtps Returns Boolean
        Boolean bIsValid
        Integer iCodes
        Integer iCount iLastCount
        Integer iCounter

        // counter must always be increased for security reasons
        // when authentication failed, increase with required number of codes
        Get piCounter to iCounter

        Get RequiredNumberOfCodes to iCodes
        Move (iCodes-1) to iLastCount
        For iCount from 0 to iLastCount
            Get IsValidCode asEnteredOtps[iCount] (iCount=0) to bIsValid
            If not bIsValid Break
        Loop

        // advance counter to mitigate brute force attacks
        If not bIsValid ;
            Set piCounter to (iCounter + iCodes)

        Function_Return bIsValid
    End_Function

End_Class

Class cSecureTimeBasedOneTimePassword_Impl is a cSecureOneTimePassword_Impl_Base

    Procedure Construct_Object
        Forward Send Construct_Object

        // step size (in seconds) for factor
        Property UBigInt piStep 30

        // The number of past OTP values to try, in case the client is slow or the client clock is running late.
        // Security is lower when this value is higher!
        Property UBigInt piGraceCountBack 2

        // The number of future OTP values to try, in case the client is extremely fast or the client clock is running ahead.
        // Security is lower when this value is higher!
        Property UBigInt piGraceCountForward 1
    End_Procedure

    // ignores unknown parameters
    Procedure UnpackParameterFromStorage String sParam
        Integer iPos
        String  sKey
        String  sValue

        Move (Pos('=', sParam)) to iPos
        If (iPos = 0) Begin
            Error DFERR_PROGRAM "Invalid OTP storage string"
            Procedure_Return
        End

        Move (Mid(sParam, iPos-1, 1)) to sKey
        Move (Mid(sParam, Length(sParam)-iPos, iPos+1)) to sValue

        Case Begin
            Case (sKey = 'period')
                Set piStep to sValue
                Case Break
            Case Else
                Forward Send UnpackParameterFromStorage sParam
        Case End
    End_Procedure

    // @returns the number of authentication codes required.
    Function RequiredNumberOfCodes Returns Integer
        Function_Return 1
    End_Function

    { Visibility=Private }
    Function QrCodeUriType Returns String
        Function_Return "totp"
    End_Function

    { Visibility=Private }
    Function QrCodeUriParameters String sBase32Secret Returns String[][]
        Integer iParam
        String[][] asParams

        Forward Get QrCodeUriParameters sBase32Secret to asParams
        Move (SizeOfArray(asParams)) to iParam

        Move "period" to asParams[iParam][0]
        Move 30 to asParams[iParam][1]
        Increment iParam

        Function_Return asParams
    End_Function

    Function Should_Save Returns Boolean
        Function_Return False
    End_Function

    // Purpose  : Validates the passed code based on the current time
    // @param asEnteredOtps The OTP provided by the user, which is to be validated. For TOTP this is
    //                    a single code.
    // @param iCustomTime [optional] A custom timestamp value. If not provided the current Unix UTC
    //                    timestamp is used.
    Function IsValid String[] asEnteredOtps UBigInt iCustomTime Returns Boolean
        Boolean bIsValid
        Integer iCount
        String  sEnteredOtp
        String  sOtp
        UBigInt iCounter
        UBigInt iStep
        UBigInt iTime
        UChar[] ucaSecret

        If (SizeOfArray(asEnteredOtps) = 0) Function_Return False
        Move asEnteredOtps[0] to sEnteredOtp

        Get pucaSecret to ucaSecret

        If (num_arguments > 1) Move iCustomTime to iTime
        Else Move (CurrentUnixTime()) to iTime

        Get piStep to iStep

        // try current code first
        Move (iTime / iStep) to iCounter
        Get OneTimePassword iCounter to sOtp
        If (sOtp = sEnteredOtp) Move True to bIsValid

        // If not valid, try earlier codes
        Move 0 to iCount
        While (not(bIsValid) and iCount < piGraceCountBack(Self))
            Increment iCount

            Get OneTimePassword (iCounter - iCount) to sOtp
            If (sOtp = sEnteredOtp) Move True to bIsValid
        Loop

        // If not valid, try future codes
        Move 0 to iCount
        While (not(bIsValid) and iCount < piGraceCountForward(Self))
            Increment iCount

            Get OneTimePassword (iCounter + iCount) to sOtp
            If (sOtp = sEnteredOtp) Move True to bIsValid
        Loop

        Send SecureUCharArrayOverwrite (&ucaSecret)

        Function_Return bIsValid
    End_Function

End_Class

Class cSecureOneTimePassword is a cSecurityObject

    Procedure Construct_Object
        Forward Send Construct_Object

        { EnumList="C_SEC_HASH_CNG_HMAC_SHA1,C_SEC_HASH_CNG_HMAC_SHA256,C_SEC_HASH_CNG_HMAC_SHA512" }
        { EnumList+="C_SEC_HASH_LIBSODIUM_HMAC_SHA256,C_SEC_HASH_LIBSODIUM_HMAC_SHA512" }
        Property Integer piHashImplementation

        { EnumList="6,8" }  // 7 is allowed by RFC, but often not understood by apps
        Property Integer piDigitCount 6

        // used to disambiguate user names (e.g. e-mail address) in the app
        Property String psIssuer

        // number of consecutive to test for HOTP validation, MUST be greater than 1
        Property Integer piHotpQuantity 3
    End_Procedure

    { Visibility=Private }
    Function OneTimePassword UBigInt iCounter Returns String
        Handle  hoKeyedHash
        Integer iCount
        Integer iDigitCount
        Integer iOffset
        Integer iOTP
        String  sOTP
        UChar[] ucaCounter
        UChar[] ucaHMAC
        UChar[] ucaSecret

        Get pucaSecret to ucaSecret

        // format the counter for hashing
        Move (SizeOfType(UBigInt)-1) to iCount
        While (iCount >= 0)
            Move (iCounter iand 255) to ucaCounter[iCount]
            Move (iCounter/256) to iCounter
            Decrement iCount
        Loop

        // generate the hash
        Get CreateNamed (RefClass(cSecureHash)) "cSecureHash_OTP" to hoKeyedHash
        Set piHashImplementation of hoKeyedHash to (piHashImplementation(Self))
        Send Initialize of hoKeyedHash ucaSecret
        Send Update of hoKeyedHash ucaCounter
        Get Finalize of hoKeyedHash to ucaHMAC
        Send Destroy of hoKeyedHash

        // extract the OTP value
        Move (ucaHMAC[SizeOfArray(ucaHMAC)-1] iand $0F) to iOffset
        Move (ucaHMAC[iOffset] iand $7F) to iOTP
        Move (iOTP * 256) to iOTP
        Add (ucaHMAC[iOffset+1] iand $FF) to iOTP
        Move (iOTP * 256) to iOTP
        Add (ucaHMAC[iOffset+2] iand $FF) to iOTP
        Move (iOTP * 256) to iOTP
        Add (ucaHMAC[iOffset+3] iand $FF) to iOTP

        // format the OTP string
        Get piDigitCount to iDigitCount
        Move (Right("0000000" + String(iOTP), iDigitCount)) to sOTP

        Function_Return sOTP
    End_Function

    // @param eType the type of OTP, C_SEC_OTPTYPE_HASH or C_SEC_OTPTYPE_TIME
    Function NewOtp String eType String sAccountName Returns Handle
        Handle hoOtp

        Case Begin
            Case (eType = C_SEC_OTPTYPE_HASH)
                Get CreateNamed (RefClass(cSecureHmacBasedOneTimePassword_Impl)) "cSecureHmacBasedOneTimePassword_Impl" to hoOtp
                Set piHotpQuantity of hoOtp to (piHotpQuantity(Self))
                Case Break
            Case (eType = C_SEC_OTPTYPE_TIME)
                Get CreateNamed (RefClass(cSecureTimeBasedOneTimePassword_Impl)) "cSecureTimecBasedOneTimePassword_Impl" to hoOtp
                Case Break
            Case Else
                Error DFERR_PROGRAM "Unknown OTP type"
                Function_Return 0
        Case End

        Set piDigitCount of hoOtp to (piDigitCount(Self))
        Set piHashImplementation of hoOtp to (piHashImplementation(Self))
        Set psAccountName of hoOtp to sAccountName
        Set psIssuer of hoOtp to (psIssuer(Self))

        Function_Return hoOtp
    End_Function

    { Visibility=Private }
    Function IsHotp String sOtpSpec Returns Boolean
        Integer iPos iPos2
        String  sType

        Move (Pos('//', sOtpSpec)) to iPos
        If (iPos = 0) Function_Return False
        Add 2 to iPos

        // get OTP type
        Move (Pos('/', sOtpSpec, iPos)) to iPos2
        Move (Mid(sOtpSpec, iPos2, iPos)) to sType

        Function_Return (sType = C_SEC_OTPTYPE_HASH)
    End_Function

    Function UnpackFromStorage String sInput Returns Handle
        Handle   hoOtp
        Integer  iPos iPos2
        String   sLabel
        String   sType
        String[] asParts

        Move (Pos('//', sInput)) to iPos
        If (iPos = 0) Begin
            Error DFERR_PROGRAM "Invalid OTP storage string"
            Function_Return 0
        End
        Add 2 to iPos

        // get OTP type
        Move (Pos('/', sInput, iPos)) to iPos2
        Move (Mid(sInput, iPos2-iPos, iPos)) to sType
        Move (iPos2+1) to iPos

        // unpack issuer & account name
        Move (Pos('?', sInput, iPos)) to iPos2
        If (iPos2 = 0) Begin
            Error DFERR_PROGRAM "Invalid OTP storage string"
            Procedure_Return
        End
        Move (Mid(sInput, iPos2-iPos, iPos)) to sLabel
        Get UrlDecode slabel to sLabel
        Move (StrSplitToArray(sLabel, ':')) to asParts
        If (SizeOfArray(asParts) = 2) Set psIssuer to asParts[0]

        // create OTP subclass instance
        Get NewOtp sType (asParts[SizeOfArray(asParts)-1]) to hoOtp
        If (hoOtp = 0) Function_Return 0

        Send UnpackFromStorage of hoOtp sInput

        Function_Return hoOtp
    End_Function

    // @param asCodes an array of entered codes (1 for TOTP, multiple for HOTP).
    // @param sOtpSpec an OTP specification as a packed storage string.
    Function IsValid String[] asCodes String ByRef sOtpSpec Returns Boolean
        Boolean bValid
        Handle  hoOtp

        If (SizeOfArray(asCodes) = 0) Function_Return False

        Get UnpackFromStorage sOtpSpec to hoOtp
        If (hoOtp = 0) Function_Return False
        Get IsValid of hoOtp asCodes to bValid
        Send Destroy of hoOtp

        Function_Return bValid
    End_Function

    // copied from DF19.0 cWebApp class, for non-WebApp usage
    #IF !@<230
    Function UrlEncode String sValue Boolean bSegment Returns String
        String sEncoded sPart sResult
        WString wEncoded wPart
        DWord dwSize dwFlags
        Integer iRes iPart iStart

        //  The UrlEscape is limited by the maximum URL lenght so we call it chunck by chunck
        Move 0 to iStart
        Move 1000 to iPart

        If (bSegment) Begin
            Move URL_ESCAPE_SEGMENT_ONLY to dwFlags
        End

        While (iStart < Length(sValue))
            Move (Mid(sValue, iPart, iStart + 1)) to sPart

            //  Call Wide version of UrlEscape
            Move sPart to wPart
            Move (Length(sPart) + 1) to dwSize
            Move (Repeat(" ", dwSize)) to wEncoded

            Move (UrlEscapeW(AddressOf(wPart), AddressOf(wEncoded), AddressOf(dwSize), dwFlags)) to iRes

            If (Length(wPart) < dwSize) Begin
                Move (Repeat(" ", dwSize)) to wEncoded
                Move (UrlEscapeW(AddressOf(wPart), AddressOf(wEncoded), AddressOf(dwSize), dwFlags)) to iRes
            End

            Move (CString(wEncoded)) to sEncoded

            //  Do extra replacements for cookies
            Move (Replaces(";", sEncoded, "%3B")) to sEncoded
            If (bSegment) Begin
                Move (Replaces("=", sEncoded, "%3D")) to sEncoded
            End

            Move (iStart + iPart) to iStart
            Move (sResult + sEncoded) to sResult
        Loop

        Function_Return sResult
    End_Function

    // copied from DF19.0 cWebApp class, for non-WebApp usage
    Function UrlDecode String sValue Returns String
        Integer iVoid
        String  wValue
        
        If (Trim(sValue) <> "") Begin
            Move (Replaces("%3D", Replaces("%3B", sValue, ";"), "=")) to sValue
            Move sValue to wValue
            Move (UrlUnescape(AddressOf(wValue), 0, 0, URL_UNESCAPE_INPLACE)) to iVoid
            Move (CString(wValue)) to sValue
        End

        Function_Return sValue
    End_Function
    #ENDIF

End_Class
